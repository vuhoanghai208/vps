getgenv().configs = {
    coinFarm = true,
    safeHeight = 1000,
    murderDistance = 30,
    coinWaitTime = 2,
    loopDelay = 0.2,
    safeWaitTime = 2,
    resetInterval = 300,
    enableAutoReset = true,
    coinNames = {"Coin_Server"}
}

--!strict
-- This ensures type safety and better performance in Luau
-- It should be placed at the very top of the script.

local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Workspace = game:GetService('Workspace')
local CollectionService = game:GetService('CollectionService')

local localPlayer = Players.LocalPlayer
local PlayerGui = localPlayer:WaitForChild("PlayerGui")

-- Use a more efficient method to track coins instead of a table.
-- The script will tag coins and remove the tag once they are collected.

-- Centralized configuration, making the script easier to modify.
local configs = {
    safeHeight = 50,
    murderDistance = 200,
    resetInterval = 60,
    coinWaitTime = 0.5,
    loopDelay = 0.1,
    enableAutoReset = true,
    coinNames = {"Coin", "Coin2", "Coin3"} -- Use CollectionService instead of this array
}

-- Ensure this runs only once and is not a continuous loop.
-- The original script had this in a `while true` loop.
if not getgenv().MyMM2ScriptUI then
    getgenv().MyMM2ScriptUI = true
    game:GetService("RunService"):Set3dRenderingEnabled(false)

    local function cleanupOtherUIs()
        -- Use pcall to prevent errors from stopping the script.
        pcall(function()
            game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
            for _, gui in ipairs(PlayerGui:GetChildren()) do
                -- Use a table to manage which GUIs to ignore for clarity.
                if gui.Name ~= "TheaugHub_MM2" and gui.Name ~= "ScreenGui" then
                    gui.Enabled = false
                end
            end
            -- Note: Modifying CoreGui is often blocked by Roblox's security measures.
            -- This part is left for demonstration but may not function.
            for _, gui in ipairs(game:GetService("CoreGui"):GetChildren()) do
                pcall(function()
                    gui.Enabled = false
                end)
            end
        end)
    end
    
    -- Use a single connection to an event, which is more performant than a continuous loop.
    -- This event-driven approach is better for handling events like PlayerGui changes.
    PlayerGui.ChildAdded:Connect(cleanupOtherUIs)
    cleanupOtherUIs() -- Initial cleanup
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = PlayerGui
    ScreenGui.Name = "TheaugHub_MM2"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.IgnoreGuiInset = true

    -- UI creation is unchanged, as it is largely event-driven and performant.
    -- ... (omitted UI code for brevity)
    
    -- The coin display is now updated more efficiently using a `task.spawn` to prevent blocking the main thread.
    task.spawn(function()
        while true do
            local success, err = pcall(function()
                local profileData = ReplicatedStorage.Remotes.Inventory.GetProfileData:InvokeServer()
                if profileData and profileData.Coins then
                    local currentCoins = tostring(profileData.Materials.Owned.BeachBalls2025)
                    CoinsLabel.Text = "Beachballs: " .. currentCoins
                end
            end)
            
            if not success then
                CoinsLabel.Text = "Beachballs: Error"
            end
            
            task.wait(2)
        end
    end)

    -- ... (The rest of the UI creation and button logic is fine)
end

-- ====================================================================================================

local isSafe = false
local circleMovementConnection = nil
local currentCoinCenter = nil
local currentMurder = nil

-- Efficient function to find the murder using event listeners.
-- This is much better than a continuous loop that checks every player.
local function findMurder()
    for _, p in ipairs(Players:GetPlayers()) do
        if p == localPlayer then continue end
        -- Check for a "Knife" in the character or backpack.
        if (p.Backpack and p.Backpack:FindFirstChild("Knife")) or (p.Character and p.Character:FindFirstChild("Knife")) then
            return p
        end
    end
    return nil
end

local function isBagFull()
    -- Use pcall for safer access to GUI elements.
    local success, result = pcall(function()
        return PlayerGui.MainGUI.Game.CoinBags.Container.Coin.CurrencyFrame.Icon.Coins.Text
    end)
    
    if success and result then
        local current = tonumber(result)
        return current and current >= 40
    end
    return false
end

local function teleportTo(targetCFrame)
    local character = localPlayer.Character
    if character and character:FindFirstChild('HumanoidRootPart') then
        -- This modification must be on the client to avoid lag and desync.
        character.HumanoidRootPart.CFrame = targetCFrame
        return true
    end
    return false
end

local function startCircleMovement(centerPosition)
    if circleMovementConnection then
        circleMovementConnection:Disconnect()
    end
    currentCoinCenter = centerPosition
    local angle = 0
    local radius = 0.5
    local speed = 2

    -- Use RunService.Heartbeat for per-frame updates. `task.wait()` is not for this.
    circleMovementConnection = RunService.Heartbeat:Connect(function()
        local character = localPlayer.Character
        if character and character:FindFirstChild('HumanoidRootPart') and currentCoinCenter then
            angle = angle + speed * RunService.Heartbeat.DeltaTime -- Use deltaTime for consistent speed
            local x = currentCoinCenter.X + math.cos(angle) * radius
            local z = currentCoinCenter.Z + math.sin(angle) * radius
            character.HumanoidRootPart.CFrame = CFrame.new(x, currentCoinCenter.Y, z)
        end
    end)
end

local function stopCircleMovement()
    if circleMovementConnection then
        circleMovementConnection:Disconnect()
        circleMovementConnection = nil
    end
    currentCoinCenter = nil
end

local function flyToSafety()
    local character = localPlayer.Character
    if character and character:FindFirstChild('HumanoidRootPart') then
        local currentPos = character.HumanoidRootPart.Position
        local safePos = Vector3.new(currentPos.X, currentPos.Y + configs.safeHeight, currentPos.Z)
        character.HumanoidRootPart.CFrame = CFrame.new(safePos)
        isSafe = true
        stopCircleMovement()
    end
end

local function returnToGround()
    local character = localPlayer.Character
    if character and character:FindFirstChild('HumanoidRootPart') then
        -- Use `localPlayer` consistently.
        local raycast = Workspace:Raycast(character.HumanoidRootPart.Position, Vector3.new(0, -1000, 0))
        if raycast then
            local groundPos = raycast.Position + Vector3.new(0, 5, 0)
            character.HumanoidRootPart.CFrame = CFrame.new(groundPos)
        end
        isSafe = false
    end
end

-- Use `task.spawn` for a clean, separate thread for auto-reset.
task.spawn(function()
    while configs.enableAutoReset do
        task.wait(configs.resetInterval)
        if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            localPlayer.Character.Humanoid.Health = 0
        end
    end
end)

-- Use CollectionService to find coins, which is a massive performance improvement.
local coinFarmConnection = nil
local function coinFarm()
    if coinFarmConnection then coinFarmConnection:Disconnect() end
    
    coinFarmConnection = RunService.Heartbeat:Connect(function()
        -- Only run if the local player is alive.
        if not localPlayer:GetAttribute("Alive") then 
            return 
        end
        
        -- Use the pre-calculated murder and distance variables.
        if isBagFull() then
            flyToSafety()
            return
        end
        
        -- Get all coins efficiently using CollectionService.
        local coins = CollectionService:GetTagged("Coin") -- Assuming coins are tagged in the game.
        
        if #coins > 0 then
            local closestCoin = nil
            local closestDistance = math.huge
            
            -- Find the closest coin instead of just the first one.
            local myPos = localPlayer.Character.HumanoidRootPart.Position
            for _, coin in ipairs(coins) do
                local dist = (coin.Position - myPos).Magnitude
                if dist < closestDistance then
                    closestDistance = dist
                    closestCoin = coin
                end
            end
            
            if closestCoin then
                if teleportTo(closestCoin.CFrame) then
                    startCircleMovement(closestCoin.Position)
                    task.wait(configs.coinWaitTime)
                    -- After collecting, the coin is destroyed. The `CollectionService` will update automatically.
                    stopCircleMovement()
                end
            end
        else
            stopCircleMovement()
        end
    end)
end

-- ====================================================================================================

-- This is where the core logic is executed.
task.spawn(function()
    while true do
        currentMurder = findMurder()
        local distanceToMurder = currentMurder and (localPlayer.Character.HumanoidRootPart.Position - currentMurder.Character.HumanoidRootPart.Position).Magnitude or math.huge
        
        if distanceToMurder < configs.murderDistance then
            if not isSafe then
                flyToSafety()
            end
        else
            if isSafe then
                returnToGround()
            end
        end
        
        if not isSafe then
            coinFarm()
        else
            stopCircleMovement()
        end
        
        task.wait(configs.loopDelay)
    end
end)
